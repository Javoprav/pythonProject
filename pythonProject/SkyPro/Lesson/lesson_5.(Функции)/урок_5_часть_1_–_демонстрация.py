# -*- coding: utf-8 -*-
"""Урок 5 часть 1 – Демонстрация.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/14nrU466_5HlHwTjzxycANy6d-0VZXSnV

# Урок 5

## Эпизод 1 - Библиотеки

### Импорт

Мы уже упоминали о библиотеках. Библиотеки это заранее заготовленные программы для отдельных, часто встречающихся (стандартных) задач с которыми сталкиваются программисты.

Питон поставляется со многими библиотеками которые решают многие задачи. Некоторые библиотеки нужно устанавливать.

Итак, давайте воспользуемся одной из стандартных библиотек random.
Чтобы библиотеку использовать в своей программе мы должны ее импортировать.
Пишем ключевое слово import и через пробел имя библиотеки.

> import random

### Метод randint

Давайте рассмотрим самый популярный случай использования модуля random — генерацию случайного числа. Для получения случайного целого числа в Python используется функция randint()
Теперь мы можем сгенерировать число от 1 до 10
При вызове randint с такими границами диапазона может "выпасть" и 1 и 10 - обе границы диапазона включены, и об этом следует помнить.
"""

import random

print("Вывод случайного целого числа ", random.randint(0, 10))

# или

from random import randint

print("Вывод случайного целого числа ", randint(0, 10))

"""Теперь мы можем сгенерировать число от 10 до 100

"""

import random

print("Вывод случайного целого числа ", random.randint(10, 100))

"""### Метод shuffle

Метод random.shuffle() используется для перемешивания данных списка или другой изменяемой последовательности. Метод shuffle() смешивает элементы списка на месте. Он работает так как когда вы перемешайте карты в колоде.
"""

import random

my_list = [2, 5, 8, 9, 12]
print("Список до перемешивания ", my_list)

random.shuffle(my_list)
print("Вывод перемешанного списка ", my_list)

"""### Метод sample

Метод random.sample() используется, когда требуется выбрать несколько элементов из заданной последовательности.

Метод sample() возвращает список уникальных элементов, которые были выбраны из последовательности population. Итоговое количество элементов зависит от значения переданое вторым аргументом;

Наша задача перемешать буквы в строке. Так как строка не изменяемы тип данных, мы не можем воспользоваться методом shuffle. Для этого мы будем использовать метод sample. Первым аргументом передадим строку, а вторым количество элементов в этой строке. Метод вернет нам список из элементов строки. Затем с помощью метода join мы соберем строку.
"""

import random

name = "Алиса"
items = random.sample(name, 3)
result = ''.join(items)

print(result)

"""### Задача эпизода 1

Нужно написать программу которая содержит список с подарками и возвращает случайный элемент

- коробка леденцов
- желейные мишки
"""

# randint, shuffle, sample

import random

gifts = ["коробка леденцов","желейные мишки","сладкая вата", "прыгающие мячики"]

# index = random.randint(0, len(gifts) - 1)
# gift = gifts[index]

# random.shuffle(gifts)
# gift = gifts[0]

gift = random.sample(gifts, 1)[0]

print(f"Вы выиграли {gift}")

"""## Эпизод 2 - Функции

### Пример функции

int(a)
bool(a)
type(a)
print(a)
len(a)
range(a,b)

Вы уже писали программу которая кодирование букв с помощью слов. Давайте напишем эту программу с использованием функции.
"""

def alfa_tango():
    my_str = 'Papa Yankee Tango Hotel Oscar November'
    list_str = my_str.split()
    
    new_str = ''
    for word in list_str:
        new_str += word[0]
    
    print(new_str)


alfa_tango()

"""### Синтаксис функций

В языке программирования python функции определяются с помощью оператора def.
Ключевое слово def сообщает python, что перед ним определение функции. После def пишем имя функции. Оно может быть любым, также как и всякий идентификатор, например, переменная. В программировании желательно давать всему осмысленные имена. 

После имени функции ставятся скобки. В приведенном примере они пустые. Это значит, что функция не принимает никакие данные из вызывающей ее программы. Однако она могла бы их принимать, и тогда в скобках были бы указаны так называемые параметры.

После двоеточия следует тело, содержащее инструкции, которые выполняются при вызове функции. Тело функции имеет отступ. Следует различать определение функции и ее вызов. В программном коде они не рядом и не вместе. Можно определить функцию, но ни разу ее не вызвать. Нельзя вызвать функцию, которая не была определена. Определив функцию, но ни разу не вызвав ее, вы никогда не выполните ее тела.

Чтобы вызвать функцию мы пишем ее имя и ставим круглые скобки.

> alfa_tango()

### Задачка эпизода 2

Написать функцию, которая называет случайный подарок из списка 

**["коробка леденцов","желейные мишки","сладкая вата", "прыгающие мячики"]**

Вызывать ее бесконечно по нажатию на Enter.


Вызываться функция будет так:
```
random_gift()
```
"""

import random

def random_gift():
  gifts = ["коробка леденцов","желейные мишки","сладкая вата", "прыгающие мячики"]
  gift = random.sample(gifts, 1)[0]

  print(f"Вы выиграли {gift}")

while True:
  input()
  random_gift()

"""#### Зачем нужны функции?

Рассмотрим пример кода без использования функций.
Наша задача найти максимальное число в списке.
Таких списков у нас 3 шт.
"""

a = [5, 2, 3, 13, 9, 7, 99, 25, 4]
max_num_1 = 0
for i in a:
    if i > max_num_1:
        max_num_1 = i
print(max_num_1)

b = [35, 12, 38, 13, 9, 77, 101, 20, 5]
max_num_2 = 0
for i in b:
    if i > max_num_2:
        max_num_2 = i
print(max_num_2)

c = [55, 28, 33, 13, 69, 70, 89, 25, 40]
max_num_3 = 0
for i in c:
    if i > max_num_3:
        max_num_3 = i
print(max_num_3)

"""Проблема заключается в том, что нам нужно писать один и тот-же код для каждого списка. В данном примере у нас всего 3 списка, а если бы их было 10 или 30? Мы бы написали много похожего кода. 

Одно из правил в программировании говорит: "Не повторяйся". Это значит, что написаный код нужно переиспользовать. Это позволяют нам делать функции.

Напишем решение той же задачи с использованием функции.
"""

def find_max_number(number_list):
    max_num = 0
    for i in number_list:
        if i > max_num:
            max_num = i
    print(max_num)


a = [5, 2, 3, 13, 9, 7, 99, 25, 4]
b = [35, 12, 38, 13, 9, 77, 101, 20, 5]
c = [55, 28, 33, 13, 69, 70, 89, 25, 40]
find_max_number(a)
find_max_number(b)
find_max_number(c)

"""Кода стало на много меньше. Код поиска максимального числа, мы вынесли в функцию и теперь можем этот код переиспользовать, для любого каличества списков.

Функции полезны тем что мы можем их вызвать и использовать из любой точки нашей программы и не писать повторно код.

## Эпизод 3 – Возвращаемые значения

Переделать предыдущую функцию с использованием возврата результата
"""

def random_gift():
  gifts = ["коробка леденцов","желейные мишки","сладкая вата", "прыгающие мячики"]
  gift = random.sample(gifts, 1)[0]
  
  return gift


while True:
  input()
  gift = random_gift()
  print(f"Вы выиграли {gift}, поздравляем!")

"""Разберем работу return на примере калькулятора."""

def input_action():
    action_list = ['+', '-', '*', '/']
    while True:
        action = input('Введите знак действия: +, -, *, / или q для выхода \n')
        if action == 'q':
            exit()
        if action in action_list:
            return action


def input_number(message):
    while True:
        number = input(f'{message} ')
        if number.isdigit():
            return float(number)
        else:
            print('Вы ввели не число')


def calc(first_number, second_number, action):
    if action == '+':
        return first_number + second_number
    elif action == '-':
        return first_number - second_number
    elif action == '*':
        return first_number * second_number
    elif action == '/':
        return first_number / second_number


def main():
    action = input_action()
    first_number = input_number('Введите первое число: ')
    second_number = input_number('Введите второе число: ')
    result = calc(first_number, second_number, action)
    print(f'{first_number} {action} {second_number} = {result}')


main()

"""Функция main это управляющая функция. Она запускает все остальные функции.
 
Сначала мы просим пользователя ввести знак арифметического действия вызвав функцию input_action. Если он введет что-то отличное от +, -, *, / или q, программа попросит ввести знак повторно. Если пользователь ввел верный знак, то функция input_action вернет знак арифметического действия и мы занесем его в переменную action.
 
Затем мы вызываем функцию input_number передавая ей в качестве аргумента строку с сообщением. Функция input_number попросит пользователя ввести число. Если пользователь введет что-то отличное от числа, то программа сообщит об этом и попросит ввести число повторно. Если пользователь введет число, то функция input_number вернет это число и мы это значение занесем в переменную first_number и second_number. 
 
Затем когда мы уже точно уверены что к нам поступили верные данные, функции input_action и input_number их проверили, мы вызываем функцию calc и передаем ей в качестве аргументов два числа и знак арифметического действия. В функции calc мы выполним арефметическую операцию в зависимости от того какой знак арифметического действия мы передали в аргументах. И функция calc вернет нам результат. После чего мы данный результат занесем в переменную result.
 
И выведем на экран сообщение с результатом арифметического действия.
 
return позволяет нам получить результат работы функции и использовать его дальше в нашей программе.

### Чистые функции

Чистые функции – это функции, которые не имеют побочных эффектов. Необходимо самостоятельно следить за тем, чтобы функция была чистой.

Функция fun модифицирует данные, которые в нее передаются.
"""

def fun(data):
    if len(data) > 0:
        data[0] += 10
    return data*2

d1 = [1, 2, 3]
d2 = fun(d1)

print(d1)
print(d2)

"""В функцию fun был передан список, над которым был проведен ряд модификаций и сформирован новый список. При этом исходный список тоже был изменен. Это пример побочного эффекта.

Более правельный вариант будет выглядеть так.
"""

def fun(data):
    data = data[:]
    if len(data) > 0:
        data[0] += 10
    return data*2

d1 = [1, 2, 3]
d2 = fun_clear(d1)

print(d1)
print(d2)

"""В функции fun мы сделали копию списка и уже изменения проводим с копией, основной список не изменяется. Это чистая функция.

## Эпизод 4 - Обязательные аргументы функции

Когда функция вызывается, то ей передаются аргументы. Мы можем передать числа
"""

def with_tax(value, tax_percenage):
  total = value + value * tax_percenage / 100
  
  return total


print(with_tax(10000, 6))

"""А можем передать переменные


"""

def with_tax(value, tax_percenage):
  total = value + value * tax_percenage / 100
  
  return total


salary = 10000
income_tax = 6

total = with_tax(salary, income_tax)

print(total)

"""На самом деле передаются не эти переменные, а их значения. 
В данном случае числа мы могли бы писать 

> with_tax(10000, 13)

Разницы не было бы.

Когда интерпретатор переходит к функции, чтобы начать ее исполнение, он присваивает переменным-параметрам переданные в функцию значения-аргументы. В примере переменной value будет присвоено 10000, tax_percentage будет присвоено 13.

### Локальные переменные

Когда мы объявляем переменную в функции, то она видна только в этой функции. Переменные за функцией видна в функции. А теперь давайте разбираться на примере.
"""

a = 3

print("Global a = ", a)


def fun():
    a = 4
    print("Local a = ", a)


fun()

print("Global a = ", a)

"""Мы объявляем глобальную переменную a, затем такую же переменную a объявим внутри функции и присвоим ей другое значение.
И сделаем вывод в консоль значение переменной а, до функции, в функции и после ее выполнения.
Таким образом мы видим что переменная a внутри функции локальна и не как не влияет на глобальную переменную а, это две разные переменные.

Но функция может видеть глобальные переменные. Если мы не меняем ее значение внутри функции. Вот пример без объявления переменной а в функции.
"""

a = 30

print("Global a = ", a)


def fun():
    print("Local a = ", a)


fun()

print("Global a = ", a)

"""### Функции взаимодействуют друг с другом

Давайте разберем как функции взаимодействуют друг с другом и как функция может вернуть результат работы.

У нас есть программа которая запрашивает у пользователя числа через пробел. Затем должна вернуть сумму всех этих чисел.

Для этого в функции main мы запрашиваем ввод, затем разбиваем строку на элементы по пробелу с помощью метода split.

В функцию calc мы передадим получившейся список. В самой функции calc мы переберем весь список, каждый элемент преобразуем число и прибавим к i. Таким образом получив сумму всех элементов. Затем наша функция вернет результат с помощью ключевого слова return.

После того как функция закончит свою работу, ее результат будет занесен в переменную result которая находиться в функции main, там где мы и вызывали функцию calc.

Посмотрим, как это работает в  http://pythontutor.com/
"""

def calc(numbers):
    i = 0
    for number in numbers:
        i += int(number)
    return i

def main():
    numbers = input('Введите числа через пробел ')
    list_number = numbers.split(' ')
    result = calc(list_number)
    print(result)

main()

"""### Задача эпизода 4

Написать функцию, которая будет отдавать случайный подарок в зависимости от переданного ей типа подарков. 

Вызываться функция будет так:
```
random_gift(“книги”)
random_gift(“гаджеты”)
random_gift(“игры”)
```
"""

import random

def random_gift(category):
  books = ["Чистый код","Совершенный код","Паттерны ООП","Принципы","Грокаем алгоритмы"]
  gadgets = ["Умные часы","Умные весы","Робот пылесос","Экшн-камера","Умная колбаса"]
  games = ["Village","Halo Infinite","Far Cry 6","Hitman 3","The Last Of Us"]

  if category == "игры":
    return random.sample(games, 1)[0]
  elif category == "книги":
    return random.sample(books, 1)[0]
  elif category == "гаджеты":
    return random.sample(gadgets, 1)[0]
  else:
    return "Нет подарков"


print(random_gift("игры"))
print(random_gift("книги"))
print(random_gift("гаджеты"))

"""## Селфчек"""

# Как подключить библиотеку? 

import random

# или

from random import randint

# Как сгенерировать случайное число?

import random

random.randint(0,10)

# Как перемешать список?
import random

cookies = ["шоколадное", "с изюмом", "овсяное"]

random.shuffle(cookies)

print(cookies)

# Как получить случайную перемешанную последовательность из списка?

import random

cookies = ["шоколадное", "с изюмом", "овсяное"]

random.sample(cookies, 2)

# Как создать пользовательскую функцию?

def random_cookie(): 
  cookies = ["шоколадное", "с изюмом", "овсяное"]
  index = random.randint(0, len(cookies) - 1)
  
  print(cookies[index])

random_cookie()

# Как возвращать данные из функции?

def random_cookie():
  cookies = ["шоколадное", "с изюмом", "овсяное"]
  index = random.randint(0, len(cookies) - 1)
  
  return cookies[index]

cookie = random_cookie()

print(cookie)

# Как передавать значения в функцию?

import random

def random_cookies(number):
  cookies = ["шоколадное", "с изюмом", "овсяное"]
  randomized_cookies = random.sample(cookies, number)
  
  return randomized_cookies

cookie = random_cookies(2)

print(cookie)

# Что происходит, если функция пытается изменить переменные из тела основной программы?

cookie = "шоколадное"

def change_cookies():
  cookie = "обычное"

print(cookie)