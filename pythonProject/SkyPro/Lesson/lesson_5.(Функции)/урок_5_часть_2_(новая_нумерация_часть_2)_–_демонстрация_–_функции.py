# -*- coding: utf-8 -*-
"""Урок 6 (новая нумерация часть 2) – демонстрация – функции.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1aNeY1SjM6oL3dB4ldZE0ObZO85lIvQU7

### Эпизод 1 – необязательные аргументы

Предположим, нам нужно в функции считать полную сумму заказа с чаевыми но в 90 процентах процент чаевых – 10 процентов, тогда мы можем прямо принять агрумент равным 10, если аргумент придется в функцию – процент перезапишется, если нет – останется.
"""

def check(prices, tip=10):
  sum_ = sum(prices)
  total = sum_ * ( 100 + tip ) / 100

  return total



print(check([100, 300, 500]))
print(check([100, 300, 500], 0))
print(check([100, 300, 500], 20))

"""Значений по умолчанию может быть несколько, например, мы считаем сколько краски понадобится на площадь размером Ш x В. Но количество слоев краски и расход литров краски на метр может тоже меняться"""

def paint_count(width, height, consumption=0.2, layers=2):
  total = width * height * consumption * layers
  
  return total

# Такую функцию можно вызывать как с 2 аргументами, так и с 3 и даже 4

print(paint_count(3, 4))
print(paint_count(3, 4, 0.4))
print(paint_count(3, 4, 0.4, 3))

"""### Эпизод 2 – распаковка и *args

Итак,  распаковка аргументов, го посмотрим пример из презентации:
"""

def new_sum(*nums):
  print(nums)

  sum = 0

  for n in nums:
    sum += n
  
  return sum


# print("Hello", "World")

print(new_sum("Hello", "World"))

print(new_sum(1, 1, 1, 1, 1))

print(new_sum(1, 2, 4, 8, 16, 32, 64, 128))

"""На самом деле это почти все, что можно сказть о распаковке, поэтому давайте еще один пример"""

def longest_word(*words):
  leader = ""

  for word in words:
    if len(word) > len(leader): 
      leader = word

  return leader

print(longest_word("Ретро", "Бэклог", "Скрам", "Достопримечательность"))

"""Мы поработали со строками и числами, давайте поработаем со списками и определим самый длинный список"""

def longest_list(*lists):
  leader = []

  for list_ in lists:
    if len(list_) > len(leader):
      leader = list_
      
  return leader


print(longest_list([1], [1,2,3], [1,2]))

"""Наконец, если нам нужно принимать в функцию и список агрументов, и обычный аргумент, мы пишем сперва позицонный аргумент, а потом наш список, вот так:"""

def remove_from_string(string, *symbols_to_remove):
  for symbol in symbols_to_remove:
    string = string.replace(symbol,"")
  
  return string

remove_from_string("О! Смотри, можно удалить все знаки препинания сразу?", "?", "!", ",", ".", "–")
# remove_from_string("О! Смотри, можно удалить все знаки препинания сразу?", "?", "!", ",", ".", "–", " ")

"""#### Задача эпизода 2

Создать функцию, которая вычисляет среднее и возвращает его округленным до первого знака.
"""

def avg(*nums):
  count = len(nums)
  nums_sum = sum(nums)

  return round(nums_sum / count, 1)

print(avg(1,2,3,4,5))
print(avg(1,2,3,4,5,10))

"""### Эпизод 3 – хороший тон при написании функий

Функции называются маленькими буквами с подчеркиваниями, так называемый `snake_case`
"""

def getInstallment():
  # не очень хорошо
  pass

def getinstallment():
  # не очень читаемо, но допустимо
  pass

def get_installment_by_monthly_payments_lite():
  # корректно, но избыточно
  pass

def get_installment():
  # отлично
  pass

"""После декларации функций ставится два переноса строки"""

def new_sum(*nums):
  sum = 0
  for n in nums:
    sum += n
  return sum
                        # раз пустая строка
                        # два пустая строка
new_sum(5, 7, 8, 11)    # а здесь вызов функций

"""Аргументы функции разделяются запятой с пробелом"""

def any_func(arg1,arg2,arg3):
    # не очень читаемо
    pass

def any_func(arg1, arg2,arg3):
    # не очень аккуратно
    pass

def any_func(arg1, arg2, arg3):
    # отлично 
    pass

"""Если есть значения по умолчанию – равно НЕ окружается пробелами (в отличие от присваивания значения переменной)"""

# Не надо так
def precheck(prices, tip = 10):

# Лучше так
def precheck(prices, tip=10):

"""Если имя аргумента конфликтует с зарезервиованным словом, ставим в конце андер


"""

# Нельзя никогда

def any_func(class, try, finally):

# Можно

def any_func(my_class, try_number, finally_state):

# Рекомендуется

def any_func(class_, try_, finally_):

"""Документировать функции – полезно, это можно сделать с помощью 3" , такие строки называются docstring или докстринги"""

# Одной строкой можно так
def remove_from_string(string, *symbols_to_remove):
  """Удаляет символы перечисленные после первого аргумента"""

  for symbol in symbols_to_remove:
    string = string.replace(symbol,"")
  
  return string

# В опенсурсе часто рекомендуется делать так, даже для одной строки
def remove_from_string_two(string, *symbols_to_remove):
  """
  Удаляет символы перечисленные после первого аргумента
  """

  for symbol in symbols_to_remove:
    string = string.replace(symbol,"")
  
  return string


print(remove_from_string.__doc__)

"""### Эпизод 4 – тестирование функций

Чем больше мы пишем функций, тем больше наша ответственность, ведь функцию хочется написать один раз и навсегда, без ошибок и потом использовать. Но для этого нужно проверять вручную и проверять разные кейсы.

Сейчас мы за 5 минут погрузимся в очень простые автоматические тесты, буквально чтобы понять концепцию.
"""

# Решение
def ticket_price(age):
  if 0 < age < 7:
    return "Бесплатно"
  elif 7 <  age < 18:
    return "100 рублей"
  elif 18 <= age < 25:
    return "200 рублей"
  elif 25 < age < 60:
    return "300 рублей" 
  else:
    return "Ошибка"


assert ticket_price(0) == "Бесплатно", "Ошибка для 0 лет"
assert ticket_price(1) == "Бесплатно", "Ошибка для 1 лет"
assert ticket_price(7) == "100 рублей", "Ошибка для 7 лет"
assert ticket_price(18) == "200 рублей", "Ошибка для 18 лет"
assert ticket_price(25) == "300 рублей", "Ошибка для 25 лет"
assert ticket_price(60) == "Бесплатно", "Ошибка для 60 лет"
assert ticket_price(0.5) == "Бесплатно", "Ошибка для 0.5 лет"
assert ticket_price(-1) == "Бесплатно", "Ошибка для -1 лет"

"""И сразу ловим ошибку и не одну. Исправим их тут:"""

# Решение
def ticket_price(age):
  if 0 <= age < 7:
    return "Бесплатно"
  elif 7 <=  age < 18:
    return "100 рублей"
  elif 18 <= age < 25:
    return "200 рублей"
  elif 25 <= age < 60:
    return  "300 рублей" 
  elif 60 <= age:
    return  "Бесплатно"    
  else:
    return "Ошибка"


assert ticket_price(0) == "Бесплатно", "Ошибка для 0 лет"
assert ticket_price(1) == "Бесплатно", "Ошибка для 1 лет"
assert ticket_price(7) == "100 рублей", "Ошибка для 7 лет"
assert ticket_price(18) == "200 рублей", "Ошибка для 18 лет"
assert ticket_price(25) == "300 рублей", "Ошибка для 25 лет"
assert ticket_price(60) == "Бесплатно", "Ошибка для 60 лет"
assert ticket_price(0.5) == "Бесплатно", "Ошибка для 0.5 лет"
assert ticket_price(-1) == "Ошибка", "Ошибка для -1 лет"

"""Огонь, теперь наша функция надежно покрыта тестами!

#### Задачка эпизода 4

Покроем тестами и найдем ошибку
"""

# Программы выводит оценку в зависимости от количества звездочек:
def get_rating(stars):
    if stars == "*":
      return "Ужасно"
    elif stars == "**":
      return "Очень плохо"
    elif stars == "***":
      return "Средненько"
    elif stars == "****":
      return "Все в поярдке"
    elif stars == "*****":
      return "Прекрасная поездка!"
    else:
      return "Ошибка"

assert get_rating("*") == "Ужасно", "Ошибка для Ужасно"
assert get_rating("*"*2) == "Очень плохо", "Ошибка для Очень плохо"
assert get_rating("*"*3) == "Средненько", "Ошибка для Средненько"
assert get_rating("*"*4) == "Все в поярдке", "Ошибка для Все в поярдке"
assert get_rating("*"*5) == "Прекрасная поездка!", "Ошибка для Прекрасная поездка!"

assert get_rating("") == "Ошибка", "Ошибка для Ошибка"
assert get_rating("test") == "Ошибка", "Ошибка для Ошибка"

"""### Эпизод 5 - Разработка через тестирование

Разработка через тестирование начинается с тестов, а потом мы пишем сам код. 

На простом примере рассмотрим написание модифицированнй, которая считаем стоимость.
"""

# Сделаем заготовку функции

def ticket_price(age):
  return None

# Напишем к ней все тесты

assert ticket_price(0) == 0, "Ошибка для 0 лет"
assert ticket_price(0.5) == 0, "Ошибка для 0.5 лет"
assert ticket_price(1) == 0, "Ошибка для 1 лет"
assert ticket_price(6) == 0, "Ошибка для 6 лет"

assert ticket_price(7) == 100, "Ошибка для 7 лет"
assert ticket_price(17) == 100, "Ошибка для 17 лет"

assert ticket_price(18) == 200, "Ошибка для 18 лет"
assert ticket_price(24) == 200, "Ошибка для 18 лет"

assert ticket_price(25) == 300, "Ошибка для 25 лет"
assert ticket_price(30) == 300, "Ошибка для 30 лет"

assert ticket_price(60) == 0, "Ошибка для 60 лет"
assert ticket_price(61) == 0, "Ошибка для 60 лет"

assert ticket_price(-1) == "Ошибка", "Ошибка для -1 лет"

"""Тесты готовы и все они упадут, давайте напишем функцию!"""

# Частично готовая функция

# Решение
def ticket_price(age):
  if 0 <= age < 7:
    return 0
  elif 7 <=  age < 18:
    return 100
  elif 18 <= age < 25:
    return 200
  elif 25 <= age <= 60:
    return  300
  elif 60 <= age:
    return  0
  else:
    return "Ошибка"


assert ticket_price(0) == 0, "Ошибка для 0 лет"
assert ticket_price(0.5) == 0, "Ошибка для 0.5 лет"
assert ticket_price(1) == 0, "Ошибка для 1 лет"
assert ticket_price(6) == 0, "Ошибка для 6 лет"

assert ticket_price(7) == 100, "Ошибка для 7 лет"
assert ticket_price(17) == 100, "Ошибка для 17 лет"

assert ticket_price(18) == 200, "Ошибка для 18 лет"
assert ticket_price(24) == 200, "Ошибка для 18 лет"

assert ticket_price(25) == 300, "Ошибка для 25 лет"
assert ticket_price(30) == 300, "Ошибка для 30 лет"

assert ticket_price(60) == 0, "Ошибка для 60 лет"
assert ticket_price(61) == 0, "Ошибка для 60 лет"

assert ticket_price(-1) == "Ошибка", "Ошибка для -1 лет"

"""Мы поймали ошибочку, давайте исправим ее"""

# Частично готовая функция

# Решение
def ticket_price(age):
  if 0 <= age < 7:
    return 0
  elif 7 <=  age < 18:
    return 100
  elif 18 <= age < 25:
    return 200
  elif 25 <= age < 60:
    return  300
  elif 60 <= age:
    return 0
  else:
    return "Ошибка"


assert ticket_price(0) == 0, "Ошибка для 0 лет"
assert ticket_price(0.5) == 0, "Ошибка для 0.5 лет"
assert ticket_price(1) == 0, "Ошибка для 1 лет"
assert ticket_price(6) == 0, "Ошибка для 6 лет"

assert ticket_price(7) == 100, "Ошибка для 7 лет"
assert ticket_price(17) == 100, "Ошибка для 17 лет"

assert ticket_price(18) == 200, "Ошибка для 18 лет"
assert ticket_price(24) == 200, "Ошибка для 18 лет"

assert ticket_price(25) == 300, "Ошибка для 25 лет"
assert ticket_price(30) == 300, "Ошибка для 30 лет"

assert ticket_price(60) == 0, "Ошибка для 60 лет"
assert ticket_price(61) == 0, "Ошибка для 60 лет"

assert ticket_price(-1) == "Ошибка", "Ошибка для -1 лет"

"""А теперь самое крутое. Предположим нас раздражает что значение 0 возвращается и в первом условии в последнем. Давайте объединим их, вот так:"""

def ticket_price(age):
  if (0 <= age < 7) or (age > 60):
    return 0
  elif 7 <=  age < 18:
    return 100
  elif 18 <= age < 25:
    return 200
  elif 25 <= age < 60:
    return  300
  else:
    return "Ошибка"

"""Как протестировать эту функцию? Использовать те же самые тесты!"""

def ticket_price(age):
  if (0 <= age < 7) or (age >= 60):
    return 0
  elif 7 <=  age < 18:
    return 100
  elif 18 <= age < 25:
    return 200
  elif 25 <= age < 60:
    return  300
  else:
    return "Ошибка"


assert ticket_price(0) == 0, "Ошибка для 0 лет"
assert ticket_price(0.5) == 0, "Ошибка для 0.5 лет"
assert ticket_price(1) == 0, "Ошибка для 1 лет"
assert ticket_price(6) == 0, "Ошибка для 6 лет"

assert ticket_price(7) == 100, "Ошибка для 7 лет"
assert ticket_price(17) == 100, "Ошибка для 17 лет"

assert ticket_price(18) == 200, "Ошибка для 18 лет"
assert ticket_price(24) == 200, "Ошибка для 18 лет"

assert ticket_price(25) == 300, "Ошибка для 25 лет"
assert ticket_price(30) == 300, "Ошибка для 30 лет"

assert ticket_price(60) == 0, "Ошибка для 60 лет"
assert ticket_price(61) == 0, "Ошибка для 60 лет"

assert ticket_price(-1) == "Ошибка", "Ошибка для -1 лет"

"""Тесты проходят, значит функция написана правильно. Отличные новости. Вот так и работают профессиональные разработчики.

Вот и вся разработка через тестирования. Принцип мы изучили, осталось изучить инструменты. А мы уже знаем, что принципы понять легче чем инструменты, да и интрументы всегда можно нагуглить!

#### Задачка эпизода 5

Заданы тесты, написать по ним функцию, возвращающиую месяц (задание из домашки 2 урока)
"""

# Решение

def month_by_number(number):
  months = ["январь", "февраль", "март", "апрель", "май", "июнь", "июль", "август", "сентябрь", "октябрь", "ноябрь", "декабрь"] 

  if number == 0 or number > 12:
    return "Ошибка"

  return months[number - 1].title()

assert month_by_number(0) == "Ошибка", "Ошибка для 0" 
assert month_by_number(1) == "Январь", "Ошибка январь"
assert month_by_number(2) == "Февраль", "Ошибка Февраль"
assert month_by_number(3) == "Март", "Ошибка Март"
assert month_by_number(4) == "Апрель", "Ошибка Апрель"
assert month_by_number(5) == "Май", "Ошибка Май"
assert month_by_number(6) == "Июнь", "Ошибка Июнь"
assert month_by_number(7) == "Июль", "Ошибка Июль"
assert month_by_number(8) == "Август", "Ошибка Август"

assert month_by_number(13) == "Ошибка", "Ошибка для 13"

"""## Селфчек"""

# Как создать функцию с аргументами, заданными по умолчанию?

def check(prices, tip=10):
  sum_ = sum(prices)
  total = sum_ * (100 + tip) / 100
  
  return total

# Как создать функцию с неопределнным количеством аргументом
# Как распаковать агрументы в список (кортеж)

def new_sum(*nums):
  sum = 0

  for n in nums:
    sum += n
  
  return sum


print(new_sum(1, 1, 1, 1, 1))

# Какие правила PEP-8 нужно соблюдать при написании функций?

Функции называются маленькими буквами с подчеркиваниями, так называемый snake_case
После декларации функций ставится два переноса строки
Аргумены функции разделяются запятой с пробелом
Если есть значения по умолчанию – равно не окружается пробелами
Если имя аргумента конфликтует с зарезервиованным словом, ставим в конце андер
Документировать функции – полезно, это можно сделать с помощью """такие строки называются docstring или докстринги"""

# Как писать тесты для функции?

assert ticket_price(0) == 0, "Ошибка для 0 лет"

# Как писать тесты и код в режиме TDD?

1. Понимаем, чего хотим
2. Пишем тесты, убеждаемся, что они падают
3. Пишем код, пока все тесты не начнут выполняться

li = [1240, 60, 230, 20, 310]
print(sum(li)/len(li))